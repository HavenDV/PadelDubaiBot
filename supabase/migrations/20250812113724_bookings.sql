revoke delete on table "public"."locations" from "anon";

revoke insert on table "public"."locations" from "anon";

revoke references on table "public"."locations" from "anon";

revoke select on table "public"."locations" from "anon";

revoke trigger on table "public"."locations" from "anon";

revoke truncate on table "public"."locations" from "anon";

revoke update on table "public"."locations" from "anon";

revoke delete on table "public"."locations" from "authenticated";

revoke insert on table "public"."locations" from "authenticated";

revoke references on table "public"."locations" from "authenticated";

revoke select on table "public"."locations" from "authenticated";

revoke trigger on table "public"."locations" from "authenticated";

revoke truncate on table "public"."locations" from "authenticated";

revoke update on table "public"."locations" from "authenticated";

revoke delete on table "public"."users" from "anon";

revoke insert on table "public"."users" from "anon";

revoke references on table "public"."users" from "anon";

revoke select on table "public"."users" from "anon";

revoke trigger on table "public"."users" from "anon";

revoke truncate on table "public"."users" from "anon";

revoke update on table "public"."users" from "anon";

revoke delete on table "public"."users" from "authenticated";

revoke insert on table "public"."users" from "authenticated";

revoke references on table "public"."users" from "authenticated";

revoke select on table "public"."users" from "authenticated";

revoke trigger on table "public"."users" from "authenticated";

revoke truncate on table "public"."users" from "authenticated";

revoke update on table "public"."users" from "authenticated";


  create table "public"."bookings" (
    "id" bigint generated by default as identity not null,
    "title" text not null,
    "start_time" timestamp with time zone not null,
    "end_time" timestamp with time zone not null,
    "location_id" bigint not null,
    "price" text not null,
    "courts" integer not null,
    "max_players" integer not null,
    "note" text,
    "chat_id" bigint not null,
    "message_id" bigint not null,
    "cancelled" boolean default false,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."bookings" enable row level security;


  create table "public"."registrations" (
    "id" bigint generated by default as identity not null,
    "booking_id" bigint not null,
    "user_id" bigint not null,
    "created_at" timestamp without time zone default now(),
    "updated_at" timestamp without time zone default now()
      );


alter table "public"."registrations" enable row level security;

CREATE UNIQUE INDEX bookings_chat_message_unique ON public.bookings USING btree (chat_id, message_id);

CREATE UNIQUE INDEX bookings_pkey ON public.bookings USING btree (id);

CREATE UNIQUE INDEX registrations_pkey ON public.registrations USING btree (id);

CREATE UNIQUE INDEX registrations_unique ON public.registrations USING btree (booking_id, user_id);

alter table "public"."bookings" add constraint "bookings_pkey" PRIMARY KEY using index "bookings_pkey";

alter table "public"."registrations" add constraint "registrations_pkey" PRIMARY KEY using index "registrations_pkey";

alter table "public"."bookings" add constraint "bookings_chat_message_unique" UNIQUE using index "bookings_chat_message_unique";

alter table "public"."bookings" add constraint "bookings_courts_check" CHECK ((courts >= 1)) not valid;

alter table "public"."bookings" validate constraint "bookings_courts_check";

alter table "public"."bookings" add constraint "bookings_location_id_fkey" FOREIGN KEY (location_id) REFERENCES locations(id) ON DELETE RESTRICT not valid;

alter table "public"."bookings" validate constraint "bookings_location_id_fkey";

alter table "public"."bookings" add constraint "bookings_max_players_check" CHECK ((max_players >= 0)) not valid;

alter table "public"."bookings" validate constraint "bookings_max_players_check";

alter table "public"."registrations" add constraint "registrations_booking_id_fkey" FOREIGN KEY (booking_id) REFERENCES bookings(id) ON DELETE CASCADE not valid;

alter table "public"."registrations" validate constraint "registrations_booking_id_fkey";

alter table "public"."registrations" add constraint "registrations_unique" UNIQUE using index "registrations_unique";

alter table "public"."registrations" add constraint "registrations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."registrations" validate constraint "registrations_user_id_fkey";

grant delete on table "public"."bookings" to "service_role";

grant insert on table "public"."bookings" to "service_role";

grant references on table "public"."bookings" to "service_role";

grant select on table "public"."bookings" to "service_role";

grant trigger on table "public"."bookings" to "service_role";

grant truncate on table "public"."bookings" to "service_role";

grant update on table "public"."bookings" to "service_role";

grant delete on table "public"."registrations" to "service_role";

grant insert on table "public"."registrations" to "service_role";

grant references on table "public"."registrations" to "service_role";

grant select on table "public"."registrations" to "service_role";

grant trigger on table "public"."registrations" to "service_role";

grant truncate on table "public"."registrations" to "service_role";

grant update on table "public"."registrations" to "service_role";


  create policy "Public bookings are viewable by everyone"
  on "public"."bookings"
  as permissive
  for select
  to authenticated, anon
using (true);



  create policy "Registrations are viewable by everyone"
  on "public"."registrations"
  as permissive
  for select
  to authenticated, anon
using (true);



  create policy "Users delete own registrations"
  on "public"."registrations"
  as permissive
  for delete
  to authenticated
using (((auth.uid())::text = (user_id)::text));



  create policy "Users manage own registrations"
  on "public"."registrations"
  as permissive
  for insert
  to authenticated
with check (((auth.uid())::text = (user_id)::text));



  create policy "Users update own registrations"
  on "public"."registrations"
  as permissive
  for update
  to authenticated
using (((auth.uid())::text = (user_id)::text))
with check (((auth.uid())::text = (user_id)::text));


CREATE TRIGGER set_bookings_updated_at BEFORE UPDATE ON public.bookings FOR EACH ROW EXECUTE FUNCTION set_updated_at();

CREATE TRIGGER set_registrations_updated_at BEFORE UPDATE ON public.registrations FOR EACH ROW EXECUTE FUNCTION set_updated_at();


